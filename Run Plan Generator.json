{"files":[{"id":"88b3c1cf-95ef-4790-a232-5adc81a29911","name":"appsscript","type":"json","source":"{\n  \"timeZone\": \"Europe/London\",\n  \"dependencies\": {},\n  \"oauthScopes\": [\n    \"https://www.googleapis.com/auth/calendar.addons.execute\",\n    \"https://www.googleapis.com/auth/calendar.events\",\n    \"https://www.googleapis.com/auth/calendar\"\n  ],\n  \"addOns\": {\n    \"common\": {\n      \"name\": \"Run Plan Generator\",\n      \"logoUrl\": \"https://encrypted-tbn0.gstatic.com/images?q\u003dtbn:ANd9GcRFIhF2YPG9gfSCosaXcy8UxujZoHpKyTWzyA\u0026s\",\n      \"layoutProperties\": {\n        \"primaryColor\": \"#4285F4\"\n      }\n    },\n    \"calendar\": {\n      \"homepageTrigger\": {\n        \"runFunction\": \"onHomepageOpen\"\n      }\n    }\n  },\n  \"runtimeVersion\": \"V8\"\n}"},{"id":"1fcfb9da-47ab-4adb-9673-02aeb9b52d7d","name":"Code","type":"server_js","source":"/**\n * RunPlanGenerator for Google Apps Script\n * \n * Generates weekly running schedules based on total distance and start date.\n * Creates calendar events for each run.\n */\n\n/**\n * Pace settings in seconds per kilometer\n */\nconst EASY_PACE \u003d 330;   // 5:30/km\nconst SPEED_PACE \u003d 235;  // 3:55/km\n\n/**\n * Entry point for the Google Apps Script add-on\n */\nfunction onHomepageOpen(e) {\n  return showRunPlannerCard(e);\n}\n\n/**\n * Show the main run planner interface\n */\nfunction showRunPlannerCard() {\n  const distanceInput \u003d CardService.newTextInput()\n    .setFieldName(\"distance\")\n    .setTitle(\"Weekly Distance (km)\")\n    .setValue(\"50\")\n    .setHint(\"Enter your target weekly distance (10-200km)\");\n\n  // Use current date as default, formatted for better compatibility\n  const today \u003d new Date();\n  const dateInput \u003d CardService.newDatePicker()\n    .setFieldName(\"startDate\")\n    .setTitle(\"Start Date\")\n    .setValueInMsSinceEpoch(today.getTime());\n\n  const daysInput \u003d CardService.newTextInput()\n    .setFieldName(\"days\")\n    .setTitle(\"Training Days per Week\")\n    .setValue(\"4\")\n    .setHint(\"Number of running days (1-7)\");\n\n  const generateAction \u003d CardService.newAction()\n    .setFunctionName(\"generateRunPlan\");\n\n  const generateButton \u003d CardService.newTextButton()\n    .setText(\"Generate Run Plan\")\n    .setOnClickAction(generateAction)\n    .setTextButtonStyle(CardService.TextButtonStyle.FILLED);\n\n  const section \u003d CardService.newCardSection()\n    .addWidget(distanceInput)\n    .addWidget(dateInput)\n    .addWidget(daysInput)\n    .addWidget(generateButton);\n\n  const card \u003d CardService.newCardBuilder()\n    .setHeader(\n      CardService.newCardHeader()\n        .setTitle(\"Run Plan Generator\")\n    )\n    .addSection(section)\n    .build();\n\n  return card;\n}\n\n/**\n * Generate run plan and create calendar events\n */\nfunction generateRunPlan(e) {\n  try {\n    const formInputs \u003d e.formInputs;\n    const distance \u003d parseFloat(formInputs.distance);\n    \n    // Simplified date parsing\n    let startDate;\n    if (formInputs.startDate \u0026\u0026 formInputs.startDate[0]) {\n      // Get the date picker value (usually comes as an array)\n      if (typeof formInputs.startDate[0] \u003d\u003d\u003d \u0027object\u0027 \u0026\u0026 formInputs.startDate[0].msSinceEpoch) {\n        // Handle date picker object with msSinceEpoch\n        startDate \u003d new Date(formInputs.startDate[0].msSinceEpoch);\n      } else {\n        // Handle other formats\n        startDate \u003d new Date(formInputs.startDate[0]);\n      }\n    } else {\n      // Fallback to current date\n      startDate \u003d new Date();\n    }\n    \n    // Ensure we have a valid date\n    if (isNaN(startDate.getTime())) {\n      console.log(\u0027Date parsing failed, using current date. Input was:\u0027, formInputs.startDate);\n      startDate \u003d new Date();\n    }\n    \n    // Set to start of day\n    startDate.setHours(0, 0, 0, 0);\n    \n    const days \u003d parseInt(formInputs.days);\n\n    // Validate inputs\n    if (isNaN(distance) || distance \u003c 10 || distance \u003e 200) {\n      return showError(\"Please enter a valid distance between 10-200km\");\n    }\n    if (isNaN(days) || days \u003c 1 || days \u003e 7) {\n      return showError(\"Please enter valid training days between 1-7\");\n    }\n\n    console.log(\u0027Start date:\u0027, startDate);\n    \n    // Generate the run schedule\n    const schedule \u003d generateRunSchedule(startDate, distance, days);\n    \n    // Create calendar events\n    const calendar \u003d CalendarApp.getDefaultCalendar();\n    let eventCount \u003d 0;\n    \n    for (const run of schedule) {\n      if (run.type !\u003d\u003d \u0027rest\u0027) {\n        // Create a proper date for the calendar event\n        // Use the date from schedule and ensure it\u0027s set to the correct day\n        const eventDate \u003d new Date(run.date);\n        eventDate.setHours(7, 0, 0, 0); // Set to 7:00 AM local time\n        \n        const endDate \u003d new Date(eventDate);\n        endDate.setHours(8, 0, 0, 0); // 1 hour duration\n        \n        const title \u003d `${run.distance}km Run`;\n        const description \u003d `${run.dayName}: ${run.details}`;\n        \n        console.log(`Creating event: ${title} on ${eventDate.toDateString()} (${run.dayName})`);\n        calendar.createEvent(title, eventDate, endDate, {description: description});\n        eventCount++;\n      }\n    }\n\n    return showSuccess(`✅ Created ${eventCount} running events in your calendar!`);\n  } catch (error) {\n    console.error(\u0027Error in generateRunPlan:\u0027, error);\n    return showError(`Error generating run plan: ${error.message}`);\n  }\n}\n\n/**\n * Generate a complete weekly running schedule\n */\nfunction generateRunSchedule(startDate, distance, days) {\n  // Validate and constrain inputs\n  days \u003d Math.max(1, Math.min(7, days));\n  distance \u003d Math.max(10, Math.min(200, distance));\n\n  // Since the user always selects a Monday, use the startDate directly as Monday\n  const monday \u003d new Date(startDate);\n  monday.setHours(0, 0, 0, 0);\n  \n  console.log(\u0027Monday (start date):\u0027, monday.toDateString());\n\n  // Define days of week starting with Monday\n  const daysOfWeek \u003d [\u0027Monday\u0027, \u0027Tuesday\u0027, \u0027Wednesday\u0027, \u0027Thursday\u0027, \u0027Friday\u0027, \u0027Saturday\u0027, \u0027Sunday\u0027];\n  const schedule \u003d [];\n\n  // Calculate speed workout distance (20% + warm-up/cooldown)\n  const speedDistance \u003d Math.round((distance * 0.2) + 2);\n\n  // Determine plan types based on distance and days\n  const plan \u003d determineTrainingPlan(distance, days);\n\n  // Distribute remaining distance for easy runs\n  const remainingDistance \u003d distance - speedDistance;\n  const easyDays \u003d plan.filter(day \u003d\u003e day.type \u003d\u003d\u003d \u0027easy\u0027);\n  const longDay \u003d plan.find(day \u003d\u003e day.type \u003d\u003d\u003d \u0027long\u0027);\n  const easyDistances \u003d distributeEasyRunDistances(easyDays, remainingDistance, longDay !\u003d\u003d undefined);\n\n  // Long run distance for marathon+ weeks\n  let longDistance \u003d 0;\n  if (distance \u003e 42 \u0026\u0026 longDay) {\n    const remainingAfterEasy \u003d remainingDistance - easyDistances.reduce((sum, d) \u003d\u003e sum + d, 0);\n    longDistance \u003d Math.max(15, remainingAfterEasy);\n  }\n\n  // Round distances\n  easyDistances.forEach((dist, i) \u003d\u003e easyDistances[i] \u003d Math.round(dist * 10) / 10);\n  longDistance \u003d Math.round(longDistance * 10) / 10;\n\n  // Build schedule with actual dates\n  let easyIndex \u003d 0;\n  \n  for (let i \u003d 0; i \u003c plan.length; i++) {\n    const planDay \u003d plan[i];\n    // Calculate the actual date for this day of the week\n    const runDate \u003d new Date(monday);\n    runDate.setDate(monday.getDate() + planDay.dayIndex);\n    runDate.setHours(0, 0, 0, 0);\n    \n    // Ensure we maintain the correct date without timezone shifts\n    const runDateStr \u003d runDate.toISOString().split(\u0027T\u0027)[0];\n    \n    let runData \u003d {\n      dayName: planDay.dayName,\n      date: new Date(runDate), // Keep this as a Date object\n      dateStr: runDateStr,\n      type: planDay.type\n    };\n\n    if (planDay.type \u003d\u003d\u003d \u0027speed\u0027) {\n      const speedWorkout \u003d generateSpeedWorkout(speedDistance, runDateStr);\n      // Don\u0027t overwrite the date property\n      runData \u003d {...runData, distance: speedWorkout.distance, details: speedWorkout.details};\n    } else if (planDay.type \u003d\u003d\u003d \u0027easy\u0027) {\n      const dist \u003d easyDistances[easyIndex++];\n      const easyRun \u003d generateEasyRun(dist, runDateStr);\n      // Don\u0027t overwrite the date property\n      runData \u003d {...runData, distance: easyRun.distance, details: easyRun.details};\n    } else if (planDay.type \u003d\u003d\u003d \u0027long\u0027) {\n      const longRun \u003d generateEasyRun(longDistance, runDateStr);\n      // Don\u0027t overwrite the date property\n      runData \u003d {...runData, distance: longRun.distance, details: longRun.details};\n    }\n    \n    console.log(`${planDay.dayName} (${runData.date.toDateString()}): ${runData.type}`);\n    schedule.push(runData);\n  }\n\n  return schedule;\n}\n\n/**\n * Determine appropriate training plan based on distance and days\n * Returns an array of training days with their types and day indices\n */\nfunction determineTrainingPlan(distance, days) {\n  const daysOfWeek \u003d [\u0027Monday\u0027, \u0027Tuesday\u0027, \u0027Wednesday\u0027, \u0027Thursday\u0027, \u0027Friday\u0027, \u0027Saturday\u0027, \u0027Sunday\u0027];\n  \n  if (distance \u003e 42) {\n    // High-volume pattern for distances over 42km (marathon+)\n    // Always includes long run on Sunday, speed on Wednesday, rest strategically placed\n    return [\n      { dayName: \u0027Monday\u0027, dayIndex: 0, type: \u0027rest\u0027 },\n      { dayName: \u0027Tuesday\u0027, dayIndex: 1, type: \u0027easy\u0027 },\n      { dayName: \u0027Wednesday\u0027, dayIndex: 2, type: \u0027speed\u0027 },\n      { dayName: \u0027Thursday\u0027, dayIndex: 3, type: \u0027rest\u0027 },\n      { dayName: \u0027Friday\u0027, dayIndex: 4, type: \u0027easy\u0027 },\n      { dayName: \u0027Saturday\u0027, dayIndex: 5, type: \u0027rest\u0027 },\n      { dayName: \u0027Sunday\u0027, dayIndex: 6, type: \u0027long\u0027 }\n    ];\n  } else {\n    // Standard patterns based on training days per week\n    let plan \u003d [];\n    \n    // Initialize all days as rest\n    for (let i \u003d 0; i \u003c 7; i++) {\n      plan.push({ dayName: daysOfWeek[i], dayIndex: i, type: \u0027rest\u0027 });\n    }\n    \n    // Define training patterns for different numbers of days\n    if (days \u003d\u003d\u003d 1) {\n      plan[3].type \u003d \u0027easy\u0027; // Thursday\n    } else if (days \u003d\u003d\u003d 2) {\n      plan[1].type \u003d \u0027speed\u0027; // Tuesday\n      plan[4].type \u003d \u0027easy\u0027;  // Friday\n    } else if (days \u003d\u003d\u003d 3) {\n      plan[1].type \u003d \u0027speed\u0027; // Tuesday\n      plan[3].type \u003d \u0027easy\u0027;  // Thursday\n      plan[6].type \u003d \u0027easy\u0027;  // Sunday\n    } else if (days \u003d\u003d\u003d 4) {\n      plan[1].type \u003d \u0027speed\u0027; // Tuesday\n      plan[3].type \u003d \u0027easy\u0027;  // Thursday\n      plan[4].type \u003d \u0027easy\u0027;  // Friday\n      plan[6].type \u003d \u0027easy\u0027;  // Sunday\n    } else if (days \u003d\u003d\u003d 5) {\n      plan[1].type \u003d \u0027speed\u0027; // Tuesday\n      plan[3].type \u003d \u0027easy\u0027;  // Thursday\n      plan[4].type \u003d \u0027easy\u0027;  // Friday\n      plan[5].type \u003d \u0027easy\u0027;  // Saturday\n      plan[6].type \u003d \u0027easy\u0027;  // Sunday\n    } else if (days \u003d\u003d\u003d 6) {\n      plan[1].type \u003d \u0027speed\u0027; // Tuesday\n      plan[2].type \u003d \u0027easy\u0027;  // Wednesday\n      plan[3].type \u003d \u0027easy\u0027;  // Thursday\n      plan[4].type \u003d \u0027easy\u0027;  // Friday\n      plan[5].type \u003d \u0027easy\u0027;  // Saturday\n      plan[6].type \u003d \u0027easy\u0027;  // Sunday\n    } else if (days \u003d\u003d\u003d 7) {\n      plan[0].type \u003d \u0027easy\u0027;  // Monday\n      plan[1].type \u003d \u0027speed\u0027; // Tuesday\n      plan[2].type \u003d \u0027easy\u0027;  // Wednesday\n      plan[3].type \u003d \u0027easy\u0027;  // Thursday\n      plan[4].type \u003d \u0027easy\u0027;  // Friday\n      plan[5].type \u003d \u0027easy\u0027;  // Saturday\n      plan[6].type \u003d \u0027easy\u0027;  // Sunday\n    }\n    \n    return plan;\n  }\n}\n\n/**\n * Distribute distances for easy runs\n */\nfunction distributeEasyRunDistances(easyDays, remainingDistance, hasLongRun) {\n  const easyDistances \u003d [];\n  const easyDayCount \u003d easyDays.length;\n\n  if (easyDayCount \u003e 0) {\n    // Initial distance allocation (10km per easy day)\n    const baseEasyDistance \u003d Math.min(10, remainingDistance / easyDayCount);\n    for (let i \u003d 0; i \u003c easyDayCount; i++) {\n      easyDistances.push(baseEasyDistance);\n    }\n\n    // Calculate total assigned so far\n    const totalAssigned \u003d baseEasyDistance * easyDayCount;\n\n    // Adjust if needed for high-volume weeks\n    if (totalAssigned \u003c remainingDistance \u0026\u0026 !hasLongRun) {\n      // Distribute remaining evenly if no long run\n      const surplus \u003d remainingDistance - totalAssigned;\n      const surplusPerDay \u003d surplus / easyDayCount;\n\n      for (let i \u003d 0; i \u003c easyDayCount; i++) {\n        easyDistances[i] +\u003d surplusPerDay;\n      }\n    }\n  }\n\n  return easyDistances;\n}\n\n/**\n * Generate a speed/interval workout\n */\nfunction generateSpeedWorkout(distance, date) {\n  // 2km for warm-up/cool-down, rest is intervals\n  const numOfIntervals \u003d distance - 2;\n\n  // Workout types (by distance in meters)\n  const options \u003d [1, 2, 4, 6, 8]; // 1\u003d1000m, 2\u003d2000m, 4\u003d400m, 6\u003d600m, 8\u003d800m\n  const randomNumber \u003d options[Math.floor(Math.random() * options.length)];\n\n  let intervalCount \u003d 0;\n  let restTime \u003d 0;\n  let intervalPace \u003d SPEED_PACE;\n  let intervalType \u003d \"\";\n\n  // Configure workout parameters based on interval type\n  switch (randomNumber) {\n    case 1: // 1km intervals\n      intervalCount \u003d numOfIntervals;\n      restTime \u003d 75;\n      intervalPace \u003d SPEED_PACE - 5;\n      intervalType \u003d \"1km\";\n      break;\n    case 2: // 2km intervals\n      intervalCount \u003d Math.floor(numOfIntervals / 2);\n      restTime \u003d 90;\n      intervalPace \u003d SPEED_PACE;\n      intervalType \u003d \"2km\";\n      break;\n    case 4: // 400m intervals\n      intervalCount \u003d Math.floor((numOfIntervals * 1000) / 400);\n      restTime \u003d 60;\n      intervalPace \u003d SPEED_PACE - 20;\n      intervalType \u003d \"400m\";\n      break;\n    case 6: // 600m intervals\n      intervalCount \u003d Math.floor((numOfIntervals * 1000) / 600);\n      restTime \u003d 60;\n      intervalPace \u003d SPEED_PACE - 15;\n      intervalType \u003d \"600m\";\n      break;\n    case 8: // 800m intervals\n      intervalCount \u003d Math.floor((numOfIntervals * 1000) / 800);\n      restTime \u003d 60;\n      intervalPace \u003d SPEED_PACE - 10;\n      intervalType \u003d \"800m\";\n      break;\n  }\n\n  // Format pace for display\n  const formattedPaceRange \u003d formatPaceRange(intervalPace);\n\n  // Create detailed workout description\n  const runDetails \u003d `1km, ${intervalType} × ${intervalCount} @${formattedPaceRange}/km (${restTime}s rest), 1km`;\n\n  return {\n    distance: distance,\n    details: runDetails,\n    date: date\n  };\n}\n\n/**\n * Generate an easy run\n */\nfunction generateEasyRun(distance, date) {\n  // Use standard easy pace (no temperature adjustment)\n  const pace \u003d EASY_PACE;\n\n  // Format pace as minutes:seconds\n  const minutes \u003d Math.floor(pace / 60);\n  const seconds \u003d String(pace % 60).padStart(2, \u00270\u0027);\n  const formattedPace \u003d `${minutes}:${seconds}/km`;\n\n  // Create run description\n  const runDetails \u003d `${distance}km at ${formattedPace}`;\n\n  return {\n    distance: distance,\n    details: runDetails,\n    date: date\n  };\n}\n\n/**\n * Format pace range (±5 seconds)\n */\nfunction formatPaceRange(basePace) {\n  // Calculate pace range (±5 seconds)\n  const fastPace \u003d basePace - 5;\n  const slowPace \u003d basePace + 5;\n\n  // Format paces as minutes:seconds per km\n  const fastMinutes \u003d Math.floor(fastPace / 60);\n  const fastSeconds \u003d String(fastPace % 60).padStart(2, \u00270\u0027);\n  const slowMinutes \u003d Math.floor(slowPace / 60);\n  const slowSeconds \u003d String(slowPace % 60).padStart(2, \u00270\u0027);\n\n  return `${fastMinutes}:${fastSeconds}-${slowMinutes}:${slowSeconds}`;\n}\n\n/**\n * Show success message\n */\nfunction showSuccess(message) {\n  const section \u003d CardService.newCardSection()\n    .addWidget(\n      CardService.newTextParagraph()\n        .setText(message)\n    )\n    .addWidget(\n      CardService.newTextButton()\n        .setText(\"Create Another Plan\")\n        .setOnClickAction(CardService.newAction().setFunctionName(\"showRunPlannerCard\"))\n    );\n\n  return CardService.newCardBuilder()\n    .setHeader(\n      CardService.newCardHeader()\n        .setTitle(\"Success!\")\n    )\n    .addSection(section)\n    .build();\n}\n\n/**\n * Show error message\n */\nfunction showError(message) {\n  const section \u003d CardService.newCardSection()\n    .addWidget(\n      CardService.newTextParagraph()\n        .setText(message)\n    )\n    .addWidget(\n      CardService.newTextButton()\n        .setText(\"Try Again\")\n        .setOnClickAction(CardService.newAction().setFunctionName(\"showRunPlannerCard\"))\n    );\n\n  return CardService.newCardBuilder()\n    .setHeader(\n      CardService.newCardHeader()\n        .setTitle(\"Error\")\n    )\n    .addSection(section)\n    .build();\n}"},{"id":"9510764d-902f-4e2a-9346-702c35643750","name":"Copy of Code","type":"server_js","source":"/**\n * RunPlanGenerator for Google Apps Script\n * \n * Generates weekly running schedules based on total distance and start date.\n * Creates calendar events for each run.\n */\n\n/**\n * Pace settings in seconds per kilometer\n */\nconst EASY_PACE \u003d 330;   // 5:30/km\nconst SPEED_PACE \u003d 235;  // 3:55/km\n\n/**\n * Entry point for the Google Apps Script add-on\n */\nfunction onHomepageOpen(e) {\n  return showRunPlannerCard(e);\n}\n\n/**\n * Show the main run planner interface\n */\nfunction showRunPlannerCard() {\n  const distanceInput \u003d CardService.newTextInput()\n    .setFieldName(\"distance\")\n    .setTitle(\"Weekly Distance (km)\")\n    .setValue(\"50\")\n    .setHint(\"Enter your target weekly distance (10-200km)\");\n\n  // Use current date as default, formatted for better compatibility\n  const today \u003d new Date();\n  const dateInput \u003d CardService.newDatePicker()\n    .setFieldName(\"startDate\")\n    .setTitle(\"Start Date\")\n    .setValueInMsSinceEpoch(today.getTime());\n\n  const daysInput \u003d CardService.newTextInput()\n    .setFieldName(\"days\")\n    .setTitle(\"Training Days per Week\")\n    .setValue(\"4\")\n    .setHint(\"Number of running days (1-7)\");\n\n  const generateAction \u003d CardService.newAction()\n    .setFunctionName(\"generateRunPlan\");\n\n  const generateButton \u003d CardService.newTextButton()\n    .setText(\"Generate Run Plan\")\n    .setOnClickAction(generateAction)\n    .setTextButtonStyle(CardService.TextButtonStyle.FILLED);\n\n  const section \u003d CardService.newCardSection()\n    .addWidget(distanceInput)\n    .addWidget(dateInput)\n    .addWidget(daysInput)\n    .addWidget(generateButton);\n\n  const card \u003d CardService.newCardBuilder()\n    .setHeader(\n      CardService.newCardHeader()\n        .setTitle(\"Run Plan Generator\")\n    )\n    .addSection(section)\n    .build();\n\n  return card;\n}\n\n/**\n * Generate run plan and create calendar events\n */\nfunction generateRunPlan(e) {\n  try {\n    const formInputs \u003d e.formInputs;\n    const distance \u003d parseFloat(formInputs.distance);\n    \n    // Simplified date parsing\n    let startDate;\n    if (formInputs.startDate \u0026\u0026 formInputs.startDate[0]) {\n      // Get the date picker value (usually comes as an array)\n      if (typeof formInputs.startDate[0] \u003d\u003d\u003d \u0027object\u0027 \u0026\u0026 formInputs.startDate[0].msSinceEpoch) {\n        // Handle date picker object with msSinceEpoch\n        startDate \u003d new Date(formInputs.startDate[0].msSinceEpoch);\n      } else {\n        // Handle other formats\n        startDate \u003d new Date(formInputs.startDate[0]);\n      }\n    } else {\n      // Fallback to current date\n      startDate \u003d new Date();\n    }\n    \n    // Ensure we have a valid date\n    if (isNaN(startDate.getTime())) {\n      console.log(\u0027Date parsing failed, using current date. Input was:\u0027, formInputs.startDate);\n      startDate \u003d new Date();\n    }\n    \n    // Set to start of day\n    startDate.setHours(0, 0, 0, 0);\n    \n    const days \u003d parseInt(formInputs.days);\n\n    // Validate inputs\n    if (isNaN(distance) || distance \u003c 10 || distance \u003e 200) {\n      return showError(\"Please enter a valid distance between 10-200km\");\n    }\n    if (isNaN(days) || days \u003c 1 || days \u003e 7) {\n      return showError(\"Please enter valid training days between 1-7\");\n    }\n\n    console.log(\u0027Start date:\u0027, startDate);\n    \n    // Generate the run schedule\n    const schedule \u003d generateRunSchedule(startDate, distance, days);\n    \n    // Create calendar events\n    const calendar \u003d CalendarApp.getDefaultCalendar();\n    let eventCount \u003d 0;\n    \n    for (const run of schedule) {\n      if (run.type !\u003d\u003d \u0027rest\u0027) {\n        // Create a proper date for the calendar event\n        // Use the date from schedule and ensure it\u0027s set to the correct day\n        const eventDate \u003d new Date(run.date);\n        eventDate.setHours(7, 0, 0, 0); // Set to 7:00 AM local time\n        \n        const endDate \u003d new Date(eventDate);\n        endDate.setHours(8, 0, 0, 0); // 1 hour duration\n        \n        const title \u003d `${run.distance}km Run`;\n        const description \u003d `${run.dayName}: ${run.details}`;\n        \n        console.log(`Creating event: ${title} on ${eventDate.toDateString()} (${run.dayName})`);\n        calendar.createEvent(title, eventDate, endDate, {description: description});\n        eventCount++;\n      }\n    }\n\n    return showSuccess(`✅ Created ${eventCount} running events in your calendar!`);\n  } catch (error) {\n    console.error(\u0027Error in generateRunPlan:\u0027, error);\n    return showError(`Error generating run plan: ${error.message}`);\n  }\n}\n\n/**\n * Generate a complete weekly running schedule\n */\nfunction generateRunSchedule(startDate, distance, days) {\n  // Validate and constrain inputs\n  days \u003d Math.max(1, Math.min(7, days));\n  distance \u003d Math.max(10, Math.min(200, distance));\n\n  // Since the user always selects a Monday, use the startDate directly as Monday\n  const monday \u003d new Date(startDate);\n  monday.setHours(0, 0, 0, 0);\n  \n  console.log(\u0027Monday (start date):\u0027, monday.toDateString());\n\n  // Define days of week starting with Monday\n  const daysOfWeek \u003d [\u0027Monday\u0027, \u0027Tuesday\u0027, \u0027Wednesday\u0027, \u0027Thursday\u0027, \u0027Friday\u0027, \u0027Saturday\u0027, \u0027Sunday\u0027];\n  const schedule \u003d [];\n\n  // Calculate speed workout distance (20% + warm-up/cooldown)\n  const speedDistance \u003d Math.round((distance * 0.2) + 2);\n\n  // Determine plan types based on distance and days\n  const plan \u003d determineTrainingPlan(distance, days);\n\n  // Distribute remaining distance for easy runs\n  const remainingDistance \u003d distance - speedDistance;\n  const easyDays \u003d plan.filter(day \u003d\u003e day.type \u003d\u003d\u003d \u0027easy\u0027);\n  const longDay \u003d plan.find(day \u003d\u003e day.type \u003d\u003d\u003d \u0027long\u0027);\n  const easyDistances \u003d distributeEasyRunDistances(easyDays, remainingDistance, longDay !\u003d\u003d undefined);\n\n  // Long run distance for marathon+ weeks\n  let longDistance \u003d 0;\n  if (distance \u003e 42 \u0026\u0026 longDay) {\n    const remainingAfterEasy \u003d remainingDistance - easyDistances.reduce((sum, d) \u003d\u003e sum + d, 0);\n    longDistance \u003d Math.max(15, remainingAfterEasy);\n  }\n\n  // Round distances\n  easyDistances.forEach((dist, i) \u003d\u003e easyDistances[i] \u003d Math.round(dist * 10) / 10);\n  longDistance \u003d Math.round(longDistance * 10) / 10;\n\n  // Build schedule with actual dates\n  let easyIndex \u003d 0;\n  \n  for (let i \u003d 0; i \u003c plan.length; i++) {\n    const planDay \u003d plan[i];\n    // Calculate the actual date for this day of the week\n    const runDate \u003d new Date(monday);\n    runDate.setDate(monday.getDate() + planDay.dayIndex);\n    runDate.setHours(0, 0, 0, 0);\n    \n    // Ensure we maintain the correct date without timezone shifts\n    const runDateStr \u003d runDate.toISOString().split(\u0027T\u0027)[0];\n    \n    let runData \u003d {\n      dayName: planDay.dayName,\n      date: new Date(runDate), // Keep this as a Date object\n      dateStr: runDateStr,\n      type: planDay.type\n    };\n\n    if (planDay.type \u003d\u003d\u003d \u0027speed\u0027) {\n      const speedWorkout \u003d generateSpeedWorkout(speedDistance, runDateStr);\n      // Don\u0027t overwrite the date property\n      runData \u003d {...runData, distance: speedWorkout.distance, details: speedWorkout.details};\n    } else if (planDay.type \u003d\u003d\u003d \u0027easy\u0027) {\n      const dist \u003d easyDistances[easyIndex++];\n      const easyRun \u003d generateEasyRun(dist, runDateStr);\n      // Don\u0027t overwrite the date property\n      runData \u003d {...runData, distance: easyRun.distance, details: easyRun.details};\n    } else if (planDay.type \u003d\u003d\u003d \u0027long\u0027) {\n      const longRun \u003d generateEasyRun(longDistance, runDateStr);\n      // Don\u0027t overwrite the date property\n      runData \u003d {...runData, distance: longRun.distance, details: longRun.details};\n    }\n    \n    console.log(`${planDay.dayName} (${runData.date.toDateString()}): ${runData.type}`);\n    schedule.push(runData);\n  }\n\n  return schedule;\n}\n\n/**\n * Determine appropriate training plan based on distance and days\n * Returns an array of training days with their types and day indices\n */\nfunction determineTrainingPlan(distance, days) {\n  const daysOfWeek \u003d [\u0027Monday\u0027, \u0027Tuesday\u0027, \u0027Wednesday\u0027, \u0027Thursday\u0027, \u0027Friday\u0027, \u0027Saturday\u0027, \u0027Sunday\u0027];\n  \n  if (distance \u003e 42) {\n    // High-volume pattern for distances over 42km (marathon+)\n    // Always includes long run on Sunday, speed on Wednesday, rest strategically placed\n    return [\n      { dayName: \u0027Monday\u0027, dayIndex: 0, type: \u0027rest\u0027 },\n      { dayName: \u0027Tuesday\u0027, dayIndex: 1, type: \u0027easy\u0027 },\n      { dayName: \u0027Wednesday\u0027, dayIndex: 2, type: \u0027speed\u0027 },\n      { dayName: \u0027Thursday\u0027, dayIndex: 3, type: \u0027rest\u0027 },\n      { dayName: \u0027Friday\u0027, dayIndex: 4, type: \u0027easy\u0027 },\n      { dayName: \u0027Saturday\u0027, dayIndex: 5, type: \u0027rest\u0027 },\n      { dayName: \u0027Sunday\u0027, dayIndex: 6, type: \u0027long\u0027 }\n    ];\n  } else {\n    // Standard patterns based on training days per week\n    let plan \u003d [];\n    \n    // Initialize all days as rest\n    for (let i \u003d 0; i \u003c 7; i++) {\n      plan.push({ dayName: daysOfWeek[i], dayIndex: i, type: \u0027rest\u0027 });\n    }\n    \n    // Define training patterns for different numbers of days\n    if (days \u003d\u003d\u003d 1) {\n      plan[3].type \u003d \u0027easy\u0027; // Thursday\n    } else if (days \u003d\u003d\u003d 2) {\n      plan[1].type \u003d \u0027speed\u0027; // Tuesday\n      plan[4].type \u003d \u0027easy\u0027;  // Friday\n    } else if (days \u003d\u003d\u003d 3) {\n      plan[1].type \u003d \u0027speed\u0027; // Tuesday\n      plan[3].type \u003d \u0027easy\u0027;  // Thursday\n      plan[6].type \u003d \u0027easy\u0027;  // Sunday\n    } else if (days \u003d\u003d\u003d 4) {\n      plan[1].type \u003d \u0027speed\u0027; // Tuesday\n      plan[3].type \u003d \u0027easy\u0027;  // Thursday\n      plan[4].type \u003d \u0027easy\u0027;  // Friday\n      plan[6].type \u003d \u0027easy\u0027;  // Sunday\n    } else if (days \u003d\u003d\u003d 5) {\n      plan[1].type \u003d \u0027speed\u0027; // Tuesday\n      plan[3].type \u003d \u0027easy\u0027;  // Thursday\n      plan[4].type \u003d \u0027easy\u0027;  // Friday\n      plan[5].type \u003d \u0027easy\u0027;  // Saturday\n      plan[6].type \u003d \u0027easy\u0027;  // Sunday\n    } else if (days \u003d\u003d\u003d 6) {\n      plan[1].type \u003d \u0027speed\u0027; // Tuesday\n      plan[2].type \u003d \u0027easy\u0027;  // Wednesday\n      plan[3].type \u003d \u0027easy\u0027;  // Thursday\n      plan[4].type \u003d \u0027easy\u0027;  // Friday\n      plan[5].type \u003d \u0027easy\u0027;  // Saturday\n      plan[6].type \u003d \u0027easy\u0027;  // Sunday\n    } else if (days \u003d\u003d\u003d 7) {\n      plan[0].type \u003d \u0027easy\u0027;  // Monday\n      plan[1].type \u003d \u0027speed\u0027; // Tuesday\n      plan[2].type \u003d \u0027easy\u0027;  // Wednesday\n      plan[3].type \u003d \u0027easy\u0027;  // Thursday\n      plan[4].type \u003d \u0027easy\u0027;  // Friday\n      plan[5].type \u003d \u0027easy\u0027;  // Saturday\n      plan[6].type \u003d \u0027easy\u0027;  // Sunday\n    }\n    \n    return plan;\n  }\n}\n\n/**\n * Distribute distances for easy runs\n */\nfunction distributeEasyRunDistances(easyDays, remainingDistance, hasLongRun) {\n  const easyDistances \u003d [];\n  const easyDayCount \u003d easyDays.length;\n\n  if (easyDayCount \u003e 0) {\n    // Initial distance allocation (10km per easy day)\n    const baseEasyDistance \u003d Math.min(10, remainingDistance / easyDayCount);\n    for (let i \u003d 0; i \u003c easyDayCount; i++) {\n      easyDistances.push(baseEasyDistance);\n    }\n\n    // Calculate total assigned so far\n    const totalAssigned \u003d baseEasyDistance * easyDayCount;\n\n    // Adjust if needed for high-volume weeks\n    if (totalAssigned \u003c remainingDistance \u0026\u0026 !hasLongRun) {\n      // Distribute remaining evenly if no long run\n      const surplus \u003d remainingDistance - totalAssigned;\n      const surplusPerDay \u003d surplus / easyDayCount;\n\n      for (let i \u003d 0; i \u003c easyDayCount; i++) {\n        easyDistances[i] +\u003d surplusPerDay;\n      }\n    }\n  }\n\n  return easyDistances;\n}\n\n/**\n * Generate a speed/interval workout\n */\nfunction generateSpeedWorkout(distance, date) {\n  // 2km for warm-up/cool-down, rest is intervals\n  const numOfIntervals \u003d distance - 2;\n\n  // Workout types (by distance in meters)\n  const options \u003d [1, 2, 4, 6, 8]; // 1\u003d1000m, 2\u003d2000m, 4\u003d400m, 6\u003d600m, 8\u003d800m\n  const randomNumber \u003d options[Math.floor(Math.random() * options.length)];\n\n  let intervalCount \u003d 0;\n  let restTime \u003d 0;\n  let intervalPace \u003d SPEED_PACE;\n  let intervalType \u003d \"\";\n\n  // Configure workout parameters based on interval type\n  switch (randomNumber) {\n    case 1: // 1km intervals\n      intervalCount \u003d numOfIntervals;\n      restTime \u003d 75;\n      intervalPace \u003d SPEED_PACE - 5;\n      intervalType \u003d \"1km\";\n      break;\n    case 2: // 2km intervals\n      intervalCount \u003d Math.floor(numOfIntervals / 2);\n      restTime \u003d 90;\n      intervalPace \u003d SPEED_PACE;\n      intervalType \u003d \"2km\";\n      break;\n    case 4: // 400m intervals\n      intervalCount \u003d Math.floor((numOfIntervals * 1000) / 400);\n      restTime \u003d 60;\n      intervalPace \u003d SPEED_PACE - 20;\n      intervalType \u003d \"400m\";\n      break;\n    case 6: // 600m intervals\n      intervalCount \u003d Math.floor((numOfIntervals * 1000) / 600);\n      restTime \u003d 60;\n      intervalPace \u003d SPEED_PACE - 15;\n      intervalType \u003d \"600m\";\n      break;\n    case 8: // 800m intervals\n      intervalCount \u003d Math.floor((numOfIntervals * 1000) / 800);\n      restTime \u003d 60;\n      intervalPace \u003d SPEED_PACE - 10;\n      intervalType \u003d \"800m\";\n      break;\n  }\n\n  // Format pace for display\n  const formattedPaceRange \u003d formatPaceRange(intervalPace);\n\n  // Create detailed workout description\n  const runDetails \u003d `1km, ${intervalType} × ${intervalCount} @${formattedPaceRange}/km (${restTime}s rest), 1km`;\n\n  return {\n    distance: distance,\n    details: runDetails,\n    date: date\n  };\n}\n\n/**\n * Generate an easy run\n */\nfunction generateEasyRun(distance, date) {\n  // Use standard easy pace (no temperature adjustment)\n  const pace \u003d EASY_PACE;\n\n  // Format pace as minutes:seconds\n  const minutes \u003d Math.floor(pace / 60);\n  const seconds \u003d String(pace % 60).padStart(2, \u00270\u0027);\n  const formattedPace \u003d `${minutes}:${seconds}/km`;\n\n  // Create run description\n  const runDetails \u003d `${distance}km at ${formattedPace}`;\n\n  return {\n    distance: distance,\n    details: runDetails,\n    date: date\n  };\n}\n\n/**\n * Format pace range (±5 seconds)\n */\nfunction formatPaceRange(basePace) {\n  // Calculate pace range (±5 seconds)\n  const fastPace \u003d basePace - 5;\n  const slowPace \u003d basePace + 5;\n\n  // Format paces as minutes:seconds per km\n  const fastMinutes \u003d Math.floor(fastPace / 60);\n  const fastSeconds \u003d String(fastPace % 60).padStart(2, \u00270\u0027);\n  const slowMinutes \u003d Math.floor(slowPace / 60);\n  const slowSeconds \u003d String(slowPace % 60).padStart(2, \u00270\u0027);\n\n  return `${fastMinutes}:${fastSeconds}-${slowMinutes}:${slowSeconds}`;\n}\n\n/**\n * Show success message\n */\nfunction showSuccess(message) {\n  const section \u003d CardService.newCardSection()\n    .addWidget(\n      CardService.newTextParagraph()\n        .setText(message)\n    )\n    .addWidget(\n      CardService.newTextButton()\n        .setText(\"Create Another Plan\")\n        .setOnClickAction(CardService.newAction().setFunctionName(\"showRunPlannerCard\"))\n    );\n\n  return CardService.newCardBuilder()\n    .setHeader(\n      CardService.newCardHeader()\n        .setTitle(\"Success!\")\n    )\n    .addSection(section)\n    .build();\n}\n\n/**\n * Show error message\n */\nfunction showError(message) {\n  const section \u003d CardService.newCardSection()\n    .addWidget(\n      CardService.newTextParagraph()\n        .setText(message)\n    )\n    .addWidget(\n      CardService.newTextButton()\n        .setText(\"Try Again\")\n        .setOnClickAction(CardService.newAction().setFunctionName(\"showRunPlannerCard\"))\n    );\n\n  return CardService.newCardBuilder()\n    .setHeader(\n      CardService.newCardHeader()\n        .setTitle(\"Error\")\n    )\n    .addSection(section)\n    .build();\n}"}]}